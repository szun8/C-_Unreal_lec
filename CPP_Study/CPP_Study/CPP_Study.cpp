#include <iostream>
using namespace std;

// 오늘의 주제 : 불리언(bool)과 상수

// 불리언(boolean) 참/거짓
bool isHighLevel = true;
bool isPlayer = true;
bool isMale = false;

// [Note]
// 사실 bool은 그냥 1byte 정수에 불과
// 왜 정수시간에 안 다룸?
// -> 일리 있음, 어셈블리에서 bool이라는 것은 없음
//bool만 봐도 참/거짓 둘 중 하나라는 힌트를 제공(가독성)
int isFemale = 1;

// bool < 1byte 정수

// 실수
// type = float(4) double(8)

// 부동소수점 = 소수점을 유동적으로 움직이는 표현 방법
// 1) 정규화 = 0.31415926535 * 10
// 2) 31415926535 (유효숫자) 1 (지수)(<-움직인 소수점 갯수라고 생각하면 easy)

// float 부호(1) 지수(8) 유횻수자(23) = 32비트 = 4바이트
// double 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8바이트

float attackSpeed = -3.375f;
double attackSpeed2 = 123.4123;

// 예) -3.375라는 값을 저장
// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 0.5*0 + 0.25*1 + 0.125*1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단, 지수는 unsigned byte라고 가정하고 숫자 +127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000 0000 0000 0000 0000

// ==> 결과 : 디버깅 - 조사식에서 주소 검색 - 메모리창 확인 - 엔디안으로 저장되어 있으니 거꾸로 HEX 해석

// 프로그래밍할 때 부동소수점은 항상 '근사값'이라는 것을 기억
// 특히 수가 커질수록 오차 범위도 매우 커짐
// 실수 2개를 == 으로 비교하는 것은 지양

// 메모리창 : 디버그 - 창 - 메모리
// 어셈블리어 확인 : 디버그 - 창 - 디스어셈블러

int main()
{

}
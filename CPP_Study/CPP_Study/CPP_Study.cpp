#include <iostream>
using namespace std;

// 오늘의 주제 : 포인터1+2

// 단점 : 원본 수정, 유효범위가 있는 지역변수 외부 접근 X

// 선언 : TYPE* 변수이름;
// 일단 2가지 요소
// - Type 
// - *

void SetUp(int* hp) {
	*hp = 100;
}

int main()
{
	// 간단한 실습
	int hp = 1;
	SetUp(&hp);


	int number=1;

	// [저장소의 주소를 저장하는 바구니!]
	// 변수 선언할 때 * 등장했다 -> 포인터 = 주소
	// 참고) 포인터라는 바구니는 4바이트(32비트) or 8바이트(64비트) 고정크기
	int* ptr = &number;  // & : 주소 내뱉기, number의 주소를 ptr에 저장

	// 근데 남의 주소를 갖고 뭘 하라는거지?
	// 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!
	// *변수이름 = 값;

	int value1 = *ptr;
	*ptr = 2;

	// *이 여러번 등장하니 헷갈리는데, 사용 시점에 따라서 구분해 기억하자
	// 1 - 변수 선언 (주소를 저장하는 바구니다!)
	// 2 - 사용할 때(포탈타고 순간이동)

	// Type은 왜 붙여줄까?
	// * = 포인터의 의미 = 주소를 저장하는 바구니

	// 주소에 가면 뭐가 있는데?
	// ex1) 결혼식 청접장에 있는 주소 = 예식장 주소
	// ex2) 명함에 있는 주소 = 회사 주소
	// * = 포인터 (주소 바구니)

	// 받아낸 주소 속의 값이 과연 뭐인지 분석하고 받아내야하기에 TYPE 필요
	// 포인터 변수와 피포인터 변수의 타입형은 거의 일치
	// (int) number = (int)* ptr

	// BUT, 타입의 불일치
	__int64* ptr2 = (__int64*)&number; // 캐스팅
	*ptr2 = 0x0000AABBCCDDEEFF;
	// number의 자료형은 int(4byte) <-> ptr2에 저장된 값은 4바이트 이상
	// =-> number에 할당된 메모리 이상으로 그 다음 메모리영역도 사용하게됨
			// 	0x008FF800  ccddeeff  (number)
			//	0x008FF804  0000aabb  
					// 값이 덮어쓰여지는 등 예상 외의 일이 발생!
	
	return 0;
}	


